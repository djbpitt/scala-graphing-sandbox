<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>XML and JSON Manifests (CollateX Reptilian documentation)</title>
    </head>
    <body>
        <h1>CollateX Reptilian Documentation: XML and JSON Manifests</h1>
        <section>
            <h2>Synopsis</h2>
            <p>Information about the witness data to be collated must be supplied to CollateX
                Reptilian with the help of a <em>manifest</em>, which is a JSON or XML document that
                either supplies the witness data directly (JSON manifest) or contains pointers to
                where it can be found on the local file system or at a remote location (XML
                manifest). This page documents the structure of both types of manifest.</p>
            <p><em>Breaking change:</em> Earlier releases of CollateX (Java and Python) allowed file
                paths for individual witnesses to be specified on the command line. This method of
                specifying file paths is not supported in CollateX Reptilian; users who wish to use
                file paths should instead incorporate them into an XML manifest.</p>
        </section>
        <section>
            <h2>XML manifest</h2>
            <p>The following is a sample minimal XML manifest:</p>
            <pre><![CDATA[<witnesses xmlns="http://interedition.eu/collatex/ns/1.0">
  <witness siglum="A" url="localA.txt"/>
  <witness siglum="B" url="localB.txt"/>
  <witness siglum="C" url="localC.txt"/>
</witnesses>]]></pre>
            <p>The required components of an XML manifest are:</p>
            <ul>
                <li><p>All elements in an XML manifest must be in the
                        <code>http://interedition.eu/collatex/ns/1.0</code> namespace. This
                        requirement can be met, as in the example above, by specifying a default
                        namespace on the root element.</p></li>
                <li>
                    <p>The root element of an XML manifest must be
                        <code><![CDATA[<witnesses>]]></code> and it must contain two or more child
                        elements of type <code><![CDATA[<witness>]]></code>.</p></li>
                <li><p>A <code><![CDATA[<witness>]]></code> element must contain a
                        <code>@siglum</code> attribute and a <code>@url</code> attribute. The value
                        of the <code>@siglum</code> attribute will be used to represent the witness
                        siglum (identifier) in human-readable output, and it is an error if sigla
                        are not unique. The value of the <code>@url</code> attribute must be 1) a
                        relative path to a file on the local file system (relative to the location
                        of the manifest file), 2) an absolute path to a file on the local file
                        system, or 3) a remote URL that begins with <code>http://</code> or
                        <code>https://</code>. In the example above, the <code>@url</code> values
                        are all relative local paths.</p></li>
            </ul>
            <p>The order of witness information in the output formats will conform to the order of
                the <code><![CDATA[<witness>]]></code> elements in the manifest, and what this means
                is different for different formats. For example, it is absolute for table formats,
                it applies within and between agreement groups for the alignment ribbon and TEI XML
                parallel segmentation, and it applies to sigla within individual edge labels in
                graph output.
                <!-- A future release will provide the option of choosing between manifest order
                and an order computed on the basis of witness similarity. --></p>
            <p>An XML manifest supports two optional attributes, as follows:</p>
            <ul>
                <li><p>A <code>@font</code> attribute may be specified on
                        <code><![CDATA[<witnesses>]]></code> and <code><![CDATA[<witness>]]></code>
                        elements. User-specified font values will be used directly to style the
                        output in CSS, which means that they must be names that would be meaningful
                        if used as values for the CSS <code>font-family</code> property. A font
                        specified on a <code><![CDATA[<witness>]]></code> element will be used to
                        render the text of that witness in output formats that support font
                        specification (all HTML and SVG formats). A global font specified on a
                        <code><![CDATA[<witnesses>]]></code> element will be used for <em>all</em>
                        witnesses, except that a <code>@font</code> value on a
                        <code><![CDATA[<witness>]]></code> element overrides a global font
                        value.</p>
                    <p>Font specifications are supported primarily because the characters required
                        by some writing systems may be represented inadequately by system fonts, and
                        users may need to specify a font that provides appropriate coverage. If no
                        font is specified for a witness on either the
                        <code><![CDATA[<witness>]]></code> or <code><![CDATA[<witnesses>]]></code>
                        element, output will use whatever default font the browser selects. Font
                        information can be specified on a per witness basis because collations of
                        different writing systems (e.g., Old Church Slavonic and Greek) may require
                        different fonts in order to support the character inventories adequately.
                        CollateX Reptilian does not attempt to validate whether a specified font is
                        available on your system; if it is not, the browser will fall back on its
                        own default font, with unpredictable results.</p></li>
                <li><p>A <code>@color</code> attribute may be specified on either all
                        <code><![CDATA[<witness>]]></code> elements or no
                        <code><![CDATA[<witness>]]></code> elements. User-specified color values
                        will be used directly to style the output in CSS, which means that they can
                        be expressed using any color notation that CSS understands. It is an error
                        to supply a color specification for some but not all witnesses. Color is
                        used to render witness-specific background colors behind the text of
                        individual witnesses in the alignment-ribbon output format; it is ignored
                        elsewhere, including in other HTML or SVG output. CollateX Reptilian does
                        not attempt to validate whether a user-specified color value is meaningful;
                        if it is not, the fallback behavior is browser specific and therefore
                        unpredictable. If the user does not specify color values, CollateX Reptilian
                        will use a built-in default palette.</p>
                    <p>User-specified colors are supported because it is not realistic to anticipate
                        default colors that will meet the requirements of all projects by all users.
                        For example, the choice of colors may depend on the number of witnesses, and
                        also on whether the user wishes to use colors in the same range (e.g.,
                        different shades of the same basic color) to express relationships. Color
                        must be specified for all witnesses or for no witnesses because it is not
                        realistic to expect a combination of some user-specified colors and some
                        default ones to harmonize adequately. Unlike with the <code>@font</code>
                        attribute, there is no global <code>@color</code> attribute because the
                        point of color coding in the alignment-ribbon output format is to assist the
                        reader in distinguishing the witnesses from one another.</p></li>
            </ul>
            <p>Below is a sample XML manifest that specifies font and color information:</p>
            <pre><![CDATA[<witnesses xmlns="http://interedition.eu/collatex/ns/1.0" font="GlobalFont">
  <witness siglum="A" url="localA.txt" color="red"/>
  <witness siglum="B" url="localB.txt" font="WitnessBFont" color="blue"/>
  <witness siglum="C" url="localC.txt" color="green"/>
</witnesses>]]></pre>
            <p>In the example above, witnesses A and C will be rendered using the global font and
                witness B will be rendered using the witness-B font. The text of each witness will
                have a different background color in the alignment ribbon output: red for witness A,
                blue for witness B, and green for witness C.</p>
        </section>
        <section>
            <h2>JSON manifest</h2>
            <p>The CollateX Reptilian JSON manifest is an extension of the JSON input format
                supported in earlier releases of CollateX (Java and Python). All new features are
                optional, which means that CollateX Reptilian should work properly with JSON input
                developed originally for those earlier releases.</p>
            <p>The following minimal JSON manifest is copied from earlier CollateX
                documentation:</p>
            <pre>{
  "witnesses" : [
    {
      "id" : "A",
      "content" : "A black cat in a black basket"
    },
    {
      "id" : "B",
      "content" : "A black cat in a black basket"
    },
    {
      "id" : "C",
      "content" : "A striped cat in a black basket"
    },
    {
      "id" : "D",
      "content" : "A striped cat in a white basket"
    }
  ]
}</pre>
            <p>Like the XML manifest described above, the JSON manifest has required and optional
                features. The required components are:</p>
            <ul>
                <li><p>The JSON manifest is a JSON object with, at a minimum, a
                        <code>witnesses</code> property, the value of which is an array of witness
                        objects. The order of the witness objects in a JSON manifest controls the
                        order of witness information in the output formats in the same way as it
                        does in an XML manifest. A JSON manifest may also have an optional
                        <code>font</code> property, which is described below. The
                        <code>algorithm</code> and <code>tokenComparator</code> properties supported
                        in earlier version of CollateX Java and Python are ignored in CollateX
                        Reptilian.</p></li>
                <li><p>A witness object in that array must have an <code>id</code> property, which
                        will be used as a siglum value in output formats. It is an error if sigla
                        are not unique. A witness object must also have either a
                        <code>content</code> property or a <code>tokens</code> property, but not
                        both. It is an error to omit or include both of those properties; exactly
                        one of the two must be present for each witness, and not all witnesses need
                        to use the same one.</p></li>
                <li><p>The <code>content</code> property is a plain-text string, which CollateX
                        Reptilian will tokenize on whitespace and normalize by lower-casing and
                        performing Unicode normalization. Users who require alternative tokenization
                        or normalization should perform that in preprocessing and create a
                        <code>tokens</code> representation of the witness, described immediately
                        below.</p></li>
                <li><p>The representation of witness information with a <code>tokens</code> property
                        instead of a <code>content</code> property is called <em>pretokenized
                            JSON</em>. The value of the <code>tokens</code> property is an array of
                        objects, each of which represents a single token, for example:</p>
                    <pre>"tokens": [
  {
    "t": "Some ",
    "n": "some"
  },
  {
    "t": "content ",
    "n": "content",
    "x-extra": 123
  },
  {
    "t": "C"
  }
]</pre>
                    <p>A token object must have a <code>t</code> property, which represents the word
                        token as it appears in the witness. The CollateX Reptilian default
                        tokenization (used for the value of a <code>content</code> property and for
                        witnesses specified in an XML manifest) keeps trailing space with a token,
                        and the example above copies that behvaior, but users can apply alternative
                        tokenization strategies. If a token object has an <code>n</code> property,
                        that is used as the normalized value during alignment; specifying
                        <code>t</code> and <code>n</code> properties is the mechanism for users to
                        implement their own tokenization and normalization instead of using the
                        built-in defaults. If no <code>n</code> property is specified, CollateX will
                        perform default normalization, as described above. Any other property is at
                        the discretion of the user (e.g., <code>x-extra</code> in the example above)
                        and is passed through unchanged to JSON output (and discarded for other
                        output formats), with two exceptions: the property names <code>w</code> and
                        <code>g</code> are reserved for internal use by CollateX Reptilian and any
                        user-supplied values will be overwritten.</p></li>
            </ul>
            <p>A JSON manifest supports the following optional properties, with the same behavior
                and semantics as in an XML manifest:</p>
            <ul>
                <li><p>A <code>font</code> property may be specified for either the root object or
                        an individual witness object.</p></li>
                <li><p>A <code>color</code> property may be specified for either all witness objects
                        or no witness objects.</p></li>
            </ul>
            <p>Below is a sample pretokenized JSON manifest:</p>
            <pre>{
  "witnesses": [
    {
      "id": "A",
      "content": "Some content A",
      "color": "red"
    },
    {
      "id": "B",
      "content": "Some content B",
      "font": "WitnessBFont",
      "color": "blue"
    },
    {
      "id": "C",
      "color": "green",
      "tokens": [
        {
          "t": "Some ",
          "n": "some"
        },
        {
          "t": "content ",
          "n": "content",
          "x-extra": 123
        },
        {
          "t": "C"
        }
      ]
    }
  ]
}</pre>
            <p>This example includes three witnesses, with sigla <q>A</q>, <q>B</q>, and <q>C</q>
                and colors red, blue, and green, respectively. No root font is specified (that is,
                the root object does not have a <code>font</code> property), so witnesses A and C
                will be rendered using whatever default font the browser selects. Witness B
                specifies a font that will be used, if available on the system, for that witness.
                Witnesses A and B have a <code>content</code> property, so the strings will be
                tokenized and normalized using the CollateX Reptilian defaults. Witness C has a
                <code>tokens</code> property, the value of which is an array of three token objects.
                The normalization (<code>n</code> properties) will be used as the normalized form of
                the first two tokens; the third token does not include an <code>n</code> property,
                so the <code>t</code> value will be normalized according to the CollateX Reptilian
                default normalization. The <code>x-extra</code> property on the second token will be
                passed through to JSON output and discarded for other output formats.</p>
        </section>
        <hr />
        <section>
            <h2>Appendix: Schema validation</h2>
            <section>
                <p>XML manifests are validated against Relax NG and Schematron schemas. JSON
                    manifests are validated against a JSON Schema schema, with post-schema
                    validation of features that cannot be expressed within JSON Schema.</p>

            </section>
        </section>
    </body>
</html>
